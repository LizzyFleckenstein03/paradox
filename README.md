# Paradox: A self-hosted FALSE compiler for Linux x86-64

Paradox is a FALSE compiler emitting 64-bit NASM, written in FALSE itself and targeting the Linux syscall ABI.

Made for [code guessing, round #41](https://cg.esolangs.gay/41/).

Prerequisites: You need NASM and a linker in addition to paradox to compile programs.

You can use an existing FALSE implementation or the included bootstrap.lua to bootstrap paradox.

## Bootstrapping

### Using bootstrap.lua

For any given correct input, bootstrap.lua output is (supposed to be) equal to paradox output.
This means you can use bootstrap.lua as a feature-complete substitue for paradox.

```sh
# compile paradox using bootstrap.lua
./bootstrap.lua < paradox.false > paradox.asm && nasm -f elf64 paradox.asm && ld paradox.o -o paradox
```

### Using an existing FALSE implementation

Note: paradox uses ø and ß rather than O and B in its own source code. It still supports O and B; to bootstrap paradox with a FALSE implementation that does not support these symbols, use `sed -i 's/ø/O/g;s/ß/B/g' paradox.false` to substitute them.

Note: bootstrapping paradox has been tested with several standard compliant FALSE implementations. If it does not work with a certain implementation, it's likely due to a bug in that implementation.

```sh
# make paradox build itself using an existing false implementation to run paradox
existing_run_false paradox.false < paradox.false > paradox.asm && nasm -f elf64 paradox.asm && ld paradox.o -o paradox
```

## Recompiling self

Paradox can (obviously) rebuild itself once it has been bootstrapped, and the result should be equal.

```sh
# rebuild paradox using itself
./paradox < paradox.false > paradox2.asm && nasm -f elf64 paradox2.asm && ld paradox2.o -o paradox2

# verify the resulting binaries are equal
diff paradox paradox2
```

## Additional notes

### run.sh

For convenience and in accordance with the CG spec, paradox includes a `run.sh` script that will automatically compile and execute a file.

```sh
./run.sh my_file.false
```

### Error handling

Due to lack of `stderr` access in FALSE, syntax errors are emitted as `%fatal` NASM-directives, so you will see them at the assembly stage. `bootstrap.lua` uses stderr and a nonzero exit code to signal errors.

### I/O Buffering

Paradox implements buffered I/O. It uses a fixed buffer size of 8192. To change this, you can use `sed -i 's/8192/YOUR_BUFSIZE_HERE/g' paradox.false`. To find out an appropriate buffer size for your system, you can use the following command, if you have a C compiler installed:

```
echo '#include <stdio.h>\nBUFSIZ' | cpp | tail -n1
```

### Inline assembly

Paradox has its own inline assembly syntax: anything between backticks is emitted as assembly, like so:

```
"hi"

{ issue exit(0) syscall }
`mov rax, 60
mov rdi, 0
syscall
`

"bye"
```

The output should be just "hi", without "bye".

### Pointer arithmetic

Paradox (coincidentally) supports pointer arithmetic. Pointers and numbers can be added and subtracted using `+` and `-`.

Note that addition and subtraction (as well as other arithmetic and bitwise operations) operate on 32-bit numbers while pointers are 64-bit, so it will only work reliably as long as the pointers are in the appropriate range.

 `;` can be used to read from a pointer; `:` can be used to write to a pointer. Both operations read/write 64 bits.

To read and write individual bytes, one can use bitwise operations.

Variables and lambdas are pointers.

#### String pointers

`["my_stringy"]$2+;$@11+;+\[$@$@>][1-$;,\]#%%10,` will print my_stringy in reverse (ygnirts_ym). This works with any string. This is due to the binary layout of lambdas containing a single string (consisting of just a call to write with the necessary parameters):

```
0000000000401002 <fun_1>:
  401002:	48 be 00 20 40 00 00 	movabs rsi,0x402000
  401009:	00 00 00
  40100c:	b9 09 00 00 00       	mov    ecx,0x9
  401011:	e8 86 00 00 00       	call   40109c <write>
  401016:	c3                   	ret
```

(generated by `objdump -D -M intel some_binary_here`)

A pointer to the string (0x402000) is stored at offset 2, and the length of the string (0x9) is stored at offset 11.

Strings are stored in the data section, so it is possible to write to them.

It is possible to make memory allocations using strings by compiling your program like so:

```sh
(echo "[\"$(head -c YOUR_ALLOCATION_SIZE /dev/zero)\"]" && cat your_source_file.false) | ./paradox
```

In the program, you can then use `2+;` at the beginning of the file to extract a pointer to your allocation.

Since all operations fetch 64-bits, it is recommended to set the allocation size to 7 bytes higher than desired (if you wish to fetch/write the last few bytes of the allocation individually).

As an example for pointer arithmetic, see `examples/brainfuck.false` which implements brainfuck using paradox pointer arithmetic.
